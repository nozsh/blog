[{"content":"С каждым днем искусственный интеллект становится неотъемлемой частью профессионального письма, открывая новые горизонты для авторов и SEO-специалистов. Это не просто технологический тренд, а инструмент, который радикально меняет подход к созданию контента.\nЗначимость искусственного интеллекта (ИИ, AI) в написании статей:\nАвтоматизация рутинных задач: ИИ освобождает время авторов, беря на себя исследования и первичную обработку информации. Улучшение качества текста: Инструменты на базе ИИ анализируют и оптимизируют структуру и стиль написания. SEO-оптимизация: ИИ помогает выявлять и интегрировать ключевые слова, улучшая видимость статьи в поисковых системах. Переходя к основам, важно понимать, что искусственный интеллект - это не магия, а сложный набор алгоритмов, способных к обучению.\nИскусственный интеллект (ИИ) уже не фантастика, а реальность, которая кардинально изменяет процесс написания статей. Он не только ускоряет работу авторов, но и повышает качество контента, делая его более привлекательным для читателей и поисковых систем.\nВ следующем разделе мы рассмотрим, как эти алгоритмы применяются в ChatGPT для создания статей, которые могут конкурировать с текстами, написанными человеком.\nОсновы искусственного интеллекта Искусственный интеллект - это обширная область компьютерных наук, занимающаяся созданием машин, способных выполнять задачи, требующие человеческого интеллекта. Это включает в себя:\nМашинное обучение (ML, Machine Learning): Алгоритмы, обучающиеся на данных и улучшающие свою работу со временем. Обработка естественного языка (NLP, Natural Language Processing): Понимание, интерпретация и генерация человеческого языка машинами. Машинное обучение - это сердце ИИ. Это методы, которые позволяют машинам учиться на опыте, точно так же, как мы учимся на своих ошибках и успехах. Алгоритмы ML анализируют данные, находят в них закономерности и используют эти знания для принятия решений или предсказаний. Например, алгоритмы машинного обучения могут анализировать тысячи статей и выявлять, какие из них становятся популярными. Затем, на основе этого анализа, они могут предложить автору, как написать материал, который привлечет читателей.\nОбработка естественного языка - это способность машины понимать и генерировать человеческий язык. Это не просто распознавание слов, это понимание их смысла и контекста. Благодаря NLP, ИИ может не только проверять орфографию и грамматику, но и предлагать синонимы, улучшать стиль и даже создавать новый контент, основываясь на заданных параметрах.\nНо как это работает? Давайте рассмотрим на примере. Представим, что вы хотите написать статью о последних достижениях в области квантовых компьютеров. Вы даете тему ИИ, и он начинает искать информацию. Сначала он анализирует существующие материалы, разбивая их на токены, чтобы понять основные концепты и идеи. Затем, используя алгоритмы ML, ИИ определяет, какие факты и идеи будут наиболее интересны и актуальны для читателей. После этого, применяя NLP, ИИ формирует черновик статьи, который вы можете отредактировать и дополнить своими мыслями и идеями.\nТаким образом, ИИ становится не заменой автора, а его помощником, который берет на себя рутинную работу по сбору и первичной обработке информации. Это позволяет авторам сосредоточиться на творческой части процесса написания статей, внося в них свою уникальность и стиль.\nИИ не просто механический инструмент, это постоянно развивающаяся система, которая учится на каждом тексте, каждой статье, которую вы пишете. Он адаптируется к вашему стилю, учитывает ваши предпочтения и помогает создавать контент, который будет отвечать запросам вашей аудитории. И хотя ИИ может казаться чем-то из области фантастики, на самом деле это всего лишь сложный набор алгоритмов, работающих на благо человека. ИИ не заменяет человека, он делает нашу работу проще и интереснее, давая нам больше времени на творчество и инновации.\nChatGPT: ваш личный ассистент по написанию ChatGPT\rChatGPT - это искусственный интеллект, разработанный компанией OpenAI. Это вариант модели GPT (Generative Pretrained Transformer), предназначенный для генерации текста и ведения диалогов.\nСоздателями ChatGPT являются исследователи и инженеры OpenAI. OpenAI - это исследовательская организация в области искусственного интеллекта, основанная Илоном Маском и Сэмом Альтманом, которая владеет и управляет ChatGPT.\nМодель обучена на огромном наборе данных и способна выполнять различные задачи, связанные с обработкой естественного языка, такие как перевод текстов, создание контента, ответы на вопросы и многое другое.\nОсновной целью OpenAI является разработка дружелюбного ИИ, который будет способствовать благополучию человечества.\nChatGPT представляет собой одно из самых ярких проявлений искусственного интеллекта в области текстовой креативности. Этот инструмент, работающий на базе передовых алгоритмов машинного обучения, способен не только генерировать тексты, но и адаптироваться к стилю и предпочтениям пользователя, что делает его незаменимым помощником для писателей, журналистов и маркетологов.\nИнтерактивность ChatGPT позволяет ему вести диалог с пользователем, уточняя детали запроса и предлагая варианты развития текста. Это не просто автоматизация: ChatGPT стремится понять намерения пользователя и предложить наиболее релевантный контент. Он может предложить различные стили и форматы, от академических статей до поэтических произведений, обеспечивая тем самым широкий спектр творческих возможностей.\nОсновываясь на обученных моделях, ChatGPT анализирует предыдущие тексты и извлекает из них ключевые элементы, необходимые для создания нового контента. Это означает, что каждый следующий текст будет только улучшаться, поскольку система накапливает знания и опыт. Таким образом, ChatGPT не только отвечает на запросы пользователя, но и обучается, становясь со временем все более эффективным инструментом.\nПользователь может вносить коррективы и уточнять задачи, что позволяет ChatGPT точнее подстроиться под конкретные требования. Это создает ощущение работы с живым помощником, который не только выполняет указания, но и предлагает собственные идеи и решения.\nChatGPT способен не только создавать тексты с нуля, но и редактировать существующие, улучшая их структуру, стиль и SEO-оптимизацию. Это делает его ценным активом для веб-мастеров и контент-менеджеров, стремящихся улучшить видимость своих сайтов в поисковых системах.\nChatGPT мощный и гибкий инструмент, который может значительно упростить и ускорить процесс написания текстов. Он предлагает новый уровень взаимодействия между человеком и машиной, где ИИ становится не просто инструментом, но и партнером в творческом процессе. С каждым днём ChatGPT становится всё умнее и тоньше чувствует потребности пользователя, что делает его незаменимым помощником в мире цифрового контента.\nТокены Токены - это основные элементы текста, которые ИИ использует для генерации и понимания языка. Вот как они работают:\nРазбиение на токены: Текст разбивается на меньшие части, которые могут быть словами, фразами или даже символами. Обработка токенов: ИИ анализирует токены, чтобы понять контекст и смысл текста. Технология токенизации становится все более изощренной, позволяя ИИ точнее понимать и воспроизводить человеческий язык. Разработчики постоянно улучшают методы токенизации, чтобы повысить точность и естественность текста, создаваемого ИИ.\nТокены как кирпичики, из которых строится понимание текста для ИИ. Если сравнивать текст с домом, то токены - это отдельные кирпичики или даже целые блоки, из которых этот дом построен.\nКогда ИИ начинает работу с текстом, он сначала делит его на эти самые токены. Это называется токенизацией. Почему не просто слова? Потому что токены дают больше информации. Например, слово \u0026ldquo;подарок\u0026rdquo; можно разбить на токены \u0026ldquo;подар\u0026rdquo; и \u0026ldquo;ок\u0026rdquo;. Так ИИ понимает, что \u0026ldquo;подар\u0026rdquo; связан с чем-то приятным, а \u0026ldquo;ок\u0026rdquo; может быть окончанием многих слов. Это помогает ему лучше понять контекст и смысл текста.\nПриведу пример. Возьмем фразу \u0026ldquo;Саша и Маша пошли в школу\u0026rdquo;. ИИ разобьет ее на токены: \u0026ldquo;Саша\u0026rdquo;, \u0026ldquo;и\u0026rdquo;, \u0026ldquo;Маша\u0026rdquo;, \u0026ldquo;пошли\u0026rdquo;, \u0026ldquo;в\u0026rdquo;, \u0026ldquo;школу\u0026rdquo;. Затем он анализирует каждый токен, чтобы понять, кто эти люди, куда они идут и что делают. Это как если бы вы смотрели фотографию и пытались понять, что на ней изображено, анализируя каждый объект по отдельности.\nТак вот, токенизация - это первый шаг, который помогает ИИ \u0026ldquo;читать\u0026rdquo; текст. Без этого шага ИИ был бы как человек, который пытается читать книгу, не зная букв. Токены - это его алфавит, и чем лучше он им владеет, тем точнее и полнее он может передать смысл текста.\nВ общем, токены для ИИ - это то же самое, что слова для нас. Они помогают ИИ понять, что именно мы хотим сказать, и как это лучше всего сделать. И хотя для нас это может показаться чем-то сложным и непонятным, для ИИ это просто шаги, которые он должен выполнить, чтобы правильно \u0026ldquo;прочитать\u0026rdquo; наши мысли, записанные в тексте.\nИ помните, ИИ может и умный, но без нас, людей, он как безрукое чучело - видит и понимает, но сделать что-то сам не может.\nЧто важно знать о качестве генерации текста Качество текста, созданного ИИ, зависит от нескольких факторов:\nОбучающие данные: Чем качественнее и разнообразнее данные, тем лучше текст. Алгоритмы: Сложность и настройка алгоритмов определяют, насколько естественно будет звучать текст. Постобработка: Редактирование и корректировка текста после генерации улучшают его читабельность и SEO. Исследователи и разработчики постоянно работают над улучшением качества текста, генерируемого ИИ. Они стремятся создать системы, которые могут генерировать текст, неотличимый от написанного человеком, и при этом сохранять уникальность и оригинальность.\nИскусственный интеллект уже играет значительную роль в написании статей, и его влияние будет только расти. Искусственный интеллект преобразует мир написания статей, предоставляя инструменты, которые могут анализировать большие объемы данных, выявлять тенденции и создавать содержательный и убедительный контент. Возможности ИИ в написании статей огромны, и они продолжают расширяться по мере развития технологий.\nИИ позволяет создавать высококачественный контент быстрее и эффективнее, что важно в быстро меняющемся цифровом мире. Внедрение ИИ в вашу писательскую практику может значительно улучшить вашу работу и помочь достичь новых высот в SEO-оптимизации и контент-маркетинге.\nРасширенное применение машинного обучения Машинное обучение позволяет ИИ адаптироваться к различным стилям написания и предпочтениям аудитории. С помощью алгоритмов ML ИИ может определять стилистические особенности текста и адаптировать генерируемый контент под нужный тон и сложность. А так же изучать поисковые запросы и социальные медиа для предсказания интересов аудитории и создания актуального контента.\nОбработка естественного языка (NLP) позволяет ИИ не только понимать текст, но и улавливать нюансы языка, такие как ирония, юмор и эмоции.\nChatGPT может быть настроен для выполнения специфических задач, таких как:\nSEO-оптимизация: Генерация контента, оптимизированного под ключевые слова и фразы. Персонализация: Создание текстов, нацеленных на конкретную аудиторию или индивидуального пользователя. Заключение ИИ - это как умный помощник, который предлагает идеи и делает тексты лучше. Но чтобы все получилось круто, нужно правильно его использовать.\nЧтобы ИИ помогал вам писать выберите инструмент, который подходит именно вам, есть много разных ИИ, но нужен тот, который будет удобен в работе.\nСкажите ИИ, какие ключевые слова важны для вашей статьи, и какой стиль вы предпочитаете. Пусть ИИ напишет первый вариант, а вы потом его доработайте.\nИспользуйте ИИ для новых идей. Иногда ИИ может предложить что-то, до чего вы бы не додумались. Не забывайте про SEO, ИИ поможет сделать текст дружелюбным для поисковиков, но главное, чтобы он был интересен людям. Проверяйте факты, убедитесь, что информация, которую дает ИИ, точная и правдивая.\nНе полагайтесь только на ИИ. ИИ - это инструмент, а не замена вашему умению писать и мыслить. Сохраняйте свой стиль, ИИ может следовать инструкциям, но важно, чтобы текст звучал как ваш. Не пренебрегайте редактированием, ИИ напишет неплохой текст, но без доработки он может быть безликим.\nИИ может сильно помочь в написании статей, сделать этот процесс быстрее и проще. Но помните, что ИИ - это всего лишь инструмент. Он должен помогать вам, а не заменять то, что вы можете сделать сами. Правильное использование ИИ поможет сделать ваши тексты лучше и сохранить ваш уникальный стиль.\nПослесловие (Не ИИ) Эта статья полностью написана ChatGPT (4 Turbo) за исключением послесловия, и она почни не редактировалось мной вручную, но я менял текст используя промпты, говоря ИИ что и где переделать, убрать, добавить.\nВ основном мое ручное редактирование здесь - форматирование текста, деление на абзацы и придумывание некоторых заголовков.\n«И помните, ИИ может и умный, но без нас, людей, он как безрукое чучело - видит и понимает, но сделать что-то сам не может.» - ChatGPT\nДа, это тоже написал ИИ :)\nВывод: не стоит использовать ИИ для написания статьи с нуля до конца. Использовать ИИ стоит чтобы написать теорию например, или описать какой-то уже существующий фрагмент текста другими словами, в другом стиле и тп.\n","permalink":"https://nozsh.su/blog/ai-dlia-statei-chatgpt/","summary":"AI облегчает написание статей, повышая их доступность и эффективность.","title":"AI для статей - ChatGPT"},{"content":"Статья от SecurityLab.\n","permalink":"https://nozsh.su/blog/kak-kompanii-otslezhivaiut-nas-v-internete/","summary":"Ставим жирную точку в вопросах защиты своих персональных данных.","title":"Как компании отслеживают нас в Интернете? Возможно ли этого избежать?"},{"content":"Подготовка накопителя Для начала нужно подготовить флешку/диск, если ваш накопитель имеет несколько разделов, и это так не потому что вы так захотели, то их нужно удалить. Что-то по типу этого:\nЕсли же вы хотите сделать несколько разделов, на одном из которых будет 2k10 Live, то его нужно делать первым:\nМой внешний SSD диск, с 2k10 Live на разделе \u0026ldquo;zboot\u0026rdquo;, в NTFS\rЯ буду использовать флешку. Но вы можете использовать как внешний SDD, так и внешний HDD.\nВ идеале отформатировать флешку в FAT32, но вы не сможете этого сделать (законным путем на Windows) если у вас флешка объемом более 32гб. Так же из-за ограничений FAT32, вы не сможете копировать на флешку файлы больше 4гб. А копировать файлы весом больше 4гб нужно, если вы планируете устанавливать большие дистрибутивы ОС с флешки.\nФорматировать флешку в FAT32 нужно из-за огромной совместимости со старым железом. Но это можно упустить и отформатировать в NTFS. Можно было бы отформатировать в exFAT, это тот же FAT32, но без ограничений. Но с exFAT большинство старого железа не совместима, в отличии от NTFS.\nЗапись 2k10 Live на флешку И так, я буду показывать на 2k10 Live 7.37 Unofficial. У меня есть флешка на 16гб отформатированная в NTFS которую я отформатирую в FAT32.\n🚧\rТак же, касается только флешек. В конце \u0026ldquo;пути\u0026rdquo; вы можете столкнуться с проблемой, 2k10 Live не будет загружаться, так как система не сможет найти с чего загружаться.\nПоэтому лучше все же использовать FAT32 и отформатировать флешку используя RMPrepUSB.\nЭто можно пропустить если у вас SSD/HDD в NTFS.\nRMPrepUSB\rРаспаковываем образ 2k10 Live с помощью 7z. И запускаем утилиту RMPrepUSB из \\2k10\\Programs-2k10\\Flash-Utilites\\RMPrepUSB\\.\nПроверяем чтобы флешка была выбрана верно, загрузочный сектор и файловая система была как на скриншоте выше.\nНажимаем Подготовить диск.\nЕсли вы получаете ошибку \u0026ldquo;Отказано в доступе\u0026rdquo;, сначала вручную отформатируйте флешку через проводник.\nДожидаемся окончания, закрываем программу, извлекаем флешку и подключаем снова.\nЗапускаем утилиту UTmake, которая идет в комплекте с 2k10 Live. Если по какой-то причине UTMake не была скачена с ISO образом, запускаем ее из распакованного образа - \\2k10\\Programs-2k10\\Flash-Utilites\\UTmake\\.\nЭто старый скриншот с файловой системой NTFS, я делаю на FAT32\rВыбираете другой накопитель, если программа выбрала его не правильно.\nЕсли вы используете не флешку, а SSD/HDD диск, выбирайте USB-Hdd.\nДалее нажимаем Copy, чтобы скопировать содержимое ISO образа на флешку.\n💡\rЕсли кнопка Copy недоступна - переключите UFD/USB-Hdd туда и обратно.\rПосле завершения копирования, выбираем загрузчик в секции Select loader и нажимаем на Setup, если кнопки доступны. Я советую поставить Syslinux или оставить по умолчанию - Bootmgr.\nЕсли кнопки недоступны, то просто пропускаем это и идем дальше. Но если, все же это так, то вероятней всего ничего работать не будет и стоит отформатировать флешку с помощью RMPrepUSB.\nВы можете нажать на Test Disk, чтобы посмотреть работает или нет. Если вы не устанавливали загрузчик то вы особо ничего не увидите, а если устанавливали, то что-то произойдет:\nВ моем случае работал только режим UEFI, то есть EFIx64 и EFIx32. Режим Legacy не работал.\nUTMake можно закрыть.\nУстановка загрузчика Загрузчик можно не устанавливать, если у вас уже все работает, но лучше в любом случае это сделать, независимо от предыдущего шага.\nДалее ВАЖНО! Не перепутайте, вы должны в корне вашего накопителя открыть SetLDR-2k10 из \\2k10\\. То есть это нужно делать НА накопители, а не из папки откуда вы изначально запускали UTMake и где лежит образ!\nСкриншот старый, я делаю на FAT32\rВыбираем загрузчик который вам больше нравится, но я опять таки советую Syslinux, с ним будет большая совместимость со старым железом. Нажимаем Setup. Если Syslinux недоступен, то ставьте Grub4Dos.\nМожно снова запустить UTMake и нажать на \u0026ldquo;Test Disk\u0026rdquo;, чтобы проверить как работает. После того как я установил загрузчик Grub4Dos, у меня заработал Legacy режим.\nЕсли вы хотите быть точно уверены, что все работает, перезагрузитесь с этой флешки, или одолжите ПК у друга.\n📝\rТак же, если вы все делали в файловой системе NTFS, то вероятней всего загрузка UEFI работать не будет. Но это не столь критично, так как обычно новые материнские платы поддерживают Legacy, но иногда это нужно включить в настройках.\rДополнения Содержимое архивов 2k10 Addons.zip и 2k10 PMAGIC.zip нужно распаковать в корень флешки.\nСвои дистрибутивы систем Дистрибутивы Linux должны находиться в \\2k10\\User.Image\\*, а Windows в \\2k10\\User.WindS\\*.\n","permalink":"https://nozsh.su/blog/kak-sdelat-multibut-2k10-live/","summary":"Инструкция как сделать мультизагрузочную флешку/диск c 2k10 Live.","title":"Мультибут 2k10 Live"},{"content":"\r🚧\rАвтор статьи никого ни к чему не призывает!\rЭта статья написана в образовательных целях.\rНе воспринимайте написанное здесь всерьез и не повторяйте за автором.\rДля начала, разберемся как работает распаковка через терминал и что мы будем использовать при написании скрипта.\n1 \u0026#34;path\\to\\7-Zip\\7z.exe\u0026#34; x -pPASSWORD \u0026#34;path\\to\\someWinRARArchive.rar\u0026#34; -o\u0026#34;path\\to\\output\u0026#34; -y path\\to\\7-Zip\\7z.exe - это путь до 7z.exe\nx - распаковать архив\n-p - использовать пароль при распаковки\npath\\to\\someWinRARArchive.rar - путь до WinRAR архива\n-o - указать куда будет распакован архив\npath\\to\\output - путь куда будет распакован архив\n-y - Yes/Да подтвердить замену файлов, если они уже существуют.\n📝\rУказывать параметры после флагов -p и -o нужно без пробелов.\rИтак, у нас есть архив с паролем: qwerty.\nЕсли мы введем данную команду в терминал с неправильным паролем:\n1 \u0026#34;path\\to\\7-Zip\\7z.exe\u0026#34; x -p123 \u0026#34;path\\to\\someWinRARArchive.rar\u0026#34; -o\u0026#34;path\\to\\output\u0026#34; -y То мы получим ошибку:\n1 2 3 4 5 6 Can not open encrypted archive. Wrong password? Can\u0026#39;t open as archive: 1 Files: 0 Size: 0 Compressed: 0 После выполнения этой команды, мы можем использовать:\n1 2 echo %errorlevel% 2 И в ответ мы получим 2. Это означает что команда была выполнена с ошибкой. Если мы снова введем команду, но уже с верным паролем, а потом проверим errorlevel, то мы получим 0.\n1 2 3 4 5 6 7 8 9 10 11 \u0026#34;path\\to\\7-Zip\\7z.exe\u0026#34; x -pqwerty \u0026#34;path\\to\\someWinRARArchive.rar\u0026#34; -o\u0026#34;path\\to\\output\u0026#34; -y Everything is Ok Folders: 1 Files: 1 Size: 12 Compressed: 334 echo %errorlevel% 0 Из этого следует, что мы можем использовать errorlevel в скрипте, для проверки был ли пароль верен, или же нет, и подбирать пароль дальше, пока errorlevel не будет равен 0.\nСоздаем файл с расширением .bat или .cmd. Начинаем скрипт с:\n1 @echo off Чтобы скрыть лишний вывод.\nПросим пользователя ввести путь до каталога с 7z:\n1 echo - Path to 7z dir: Записываем это в переменную z7dir:\n1 set /p z7dir=\u0026#34;#: \u0026#34; Проверяем существует ли каталог 7z, если нет, то выводим ошибку:\n1 2 3 4 5 6 7 8 if not exist \u0026#34;%z7dir%\u0026#34; ( echo. echo ERROR! echo 7z dir - \u0026#34;%z7dir%\u0026#34; echo Not be found... pause exit ) Аналогично делаем с архивом:\n1 2 3 4 5 6 7 8 9 10 11 echo - Path to archive: set /p archive=\u0026#34;#: \u0026#34; if not exist \u0026#34;%archive%\u0026#34; ( echo. echo ERROR! echo Archive \u0026#34;%archive%\u0026#34; echo Not be found... pause exit ) Спрашиваем пользователя куда распаковать архив:\n1 2 echo - Path to output: set /p output=\u0026#34;#: \u0026#34; И тоже самое со словарем, где находятся пароли:\n1 2 3 4 5 6 7 8 9 10 11 echo - Path to wordlist.txt: set /p wordlist=\u0026#34;#: \u0026#34; if not exist \u0026#34;%wordlist%\u0026#34; ( echo. echo ERROR! echo Wordlist - \u0026#34;%wordlist%\u0026#34; echo Not be found... pause exit ) Далее пишем цикл, который будет построчно записывать данные из wordlist.txt в переменную, каждую итерацию:\n1 2 3 4 5 6 7 8 for /f \u0026#34;tokens=*\u0026#34; %%a in (\u0026#39;type \u0026#34;%wordlist%\u0026#34;\u0026#39;) do ( set pwd=%%a call :try ) echo. echo Oh-uh... Password not be found... pause exit Шаманим с \u0026quot;tokens=*\u0026quot; и 'type \u0026quot;%wordlist%\u0026quot;' для того, чтобы юзер мог использовать пути с пробелами.\nИ вызываем блок кода (подпрограмму) call: :try, который идет далее:\n1 2 3 4 5 6 7 8 9 10 11 :try \u0026#34;%z7dir%\\7z.exe\u0026#34; x -p%pwd% \u0026#34;%archive%\u0026#34; -o\u0026#34;%output%\u0026#34; -y \u0026gt;nul 2\u0026gt;\u0026amp;1 echo Try: %pwd% if /I %errorlevel% EQU 0 ( echo. echo Archive was successfully unpacked! echo Password is: %pwd% pause exit ) \u0026quot;%z7dir%\\7z.exe\u0026quot; x -p%pwd% \u0026quot;%archive%\u0026quot; -o\u0026quot;%output%\u0026quot; -y - команда для распаковки архива, но с нашими переменными.\n\u0026gt;nul 2\u0026gt;\u0026amp;1 - «выводит вывод» в никуда, дабы не спамить логами 7z.\necho Try: %pwd% - выводит перебираемые пароли.\nif /I %errorlevel% EQU 0 () - если выпоенная команда распаковки архива, errorlevel = 0, значит команда выполнилась успешно.\nИспользуя call :try мы вызываем подпрограмму (или же просто блок кода), который после выполнения возвращается обратно к тому месту в скрипте, где был сделан вызов, и продолжается выполнение следующих команд. В нашем случае:\n1 2 3 4 echo. echo Oh-uh... Password not be found... pause exit Уведомление о том что пароль не был подобран. Но если условие оказывается верным, мы так же видим следующие уведомление:\n1 2 3 4 5 echo. echo Archive was successfully unpacked! echo Password is: %pwd% pause exit Полный код скрипта\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @echo off :: 7z echo - Path to 7z dir: set /p z7dir=\u0026#34;#: \u0026#34; if not exist \u0026#34;%z7dir%\u0026#34; ( echo. echo ERROR! echo 7z dir - \u0026#34;%z7dir%\u0026#34; echo Not be found... pause exit ) echo Path to 7z: %z7dir% echo OK! echo. :: WinRAR Archive echo - Path to archive: set /p archive=\u0026#34;#: \u0026#34; if not exist \u0026#34;%archive%\u0026#34; ( echo. echo ERROR! echo Archive \u0026#34;%archive%\u0026#34; echo Not be found... pause exit ) echo Path to archive: %archive% echo OK! echo. :: Output echo - Path to output: set /p output=\u0026#34;#: \u0026#34; echo Path to output: %output% echo. :: Wordlist echo - Path to wordlist.txt: set /p wordlist=\u0026#34;#: \u0026#34; if not exist \u0026#34;%wordlist%\u0026#34; ( echo. echo ERROR! echo Wordlist - \u0026#34;%wordlist%\u0026#34; echo Not be found... pause exit ) echo Wordlist: %wordlist% echo OK! echo. echo Starting bruting... echo. :: Wordlist for for /f \u0026#34;tokens=*\u0026#34; %%a in (\u0026#39;type \u0026#34;%wordlist%\u0026#34;\u0026#39;) do ( set pwd=%%a call :try ) echo. echo Oh-uh... Password not be found... pause exit :try \u0026#34;%z7dir%\\7z.exe\u0026#34; x -p%pwd% \u0026#34;%archive%\u0026#34; -o\u0026#34;%output%\u0026#34; -y \u0026gt;nul 2\u0026gt;\u0026amp;1 echo Try: %pwd% if /I %errorlevel% EQU 0 ( echo. echo Archive was successfully unpacked! echo Password is: %pwd% pause exit ) Улучшения Давайте улучшим наш скрипт, и сделаем так, чтобы он в первую очередь брал значения из условного config.txt. А если файла config.txt нет, или он не полный, то скрипт будет запрашивать значения у юзера.\nДля этого придется самую малость переписать скрипт и создать config.txt:\n1 2 3 4 z7dir=path\\to\\ archive=path\\to\\ output=path\\to\\ wordlist=path\\to\\ Добавляем это в самое начало скрипта:\n1 2 3 4 5 if exist \u0026#34;config.txt\u0026#34; ( for /f \u0026#34;tokens=1,* delims==\u0026#34; %%a in (config.txt) do ( set %%a=%%b ) ) if exist \u0026quot;config.txt\u0026quot; проверяет существует ли файл config.txt, если он не существует, то соответственно код внутри блока не выполняется.\nДалее цикл, который перебирает все строки в файле:\n1 2 3 for /f \u0026#34;tokens=1,* delims==\u0026#34; %%a in (config.txt) do ( set %%a=%%b ) tokens=1,* указывает, что нужно разделить каждую строку на два токена: первый токен до знака = и второй токен - все, что после.\ndelims== устанавливает знак = в качестве разделителя.\nДля каждой строки в файле config.txt, %%a = имя переменной, а %%b = значения переменной.\nset %%a=%%b соответственно присваивает значения переменной %%a = %%b.\nТо есть выглядит это так:\n%%a = %%b z7dir = значение archive = значение output = значение wordlist = значение И как можно догадаться, порядок строк в config.txt не имеет значения.\nТеперь проверяем есть у переменной значение:\n1 2 3 4 if not defined z7dir ( echo - Path to 7z dir: set /p z7dir=\u0026#34;#: \u0026#34; ) Если переменная отсутствует в файле config.txt, или если нету самого config.txt, то значение у переменной соответственно нету, и скрипт запрашивает данные у юзера.\nЕсли же все в порядке, то скрипт просто выполняется дальше.\nМы получаем, такой немного измененный код:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if not defined z7dir ( echo - Path to 7z dir: set /p z7dir=\u0026#34;#: \u0026#34; ) if not exist \u0026#34;%z7dir%\u0026#34; ( echo. echo ERROR! echo 7z dir - \u0026#34;%z7dir%\u0026#34; echo Not be found... pause exit ) echo Path to 7z: %z7dir% echo OK! И тоже самое нужно сделать и с другими переменными.\nИ просто для галочки, сделаем чтобы юзеру нужно было подтвердить начало брута.\nНо сделаем это сразу правильно, чтобы юзер вводя абракадабру, подтверждение выводилось повторно.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 :yesornot echo Start bruting? (y/n) set /p yesornot=\u0026#34;#: \u0026#34; if /I \u0026#34;%yesornot%\u0026#34;==\u0026#34;y\u0026#34; ( call :startbruting ) else if /I \u0026#34;%yesornot%\u0026#34;==\u0026#34;n\u0026#34; ( echo OK! pause exit ) else ( echo ERROR! echo. call :yesornot ) А перед кодом, где начинается брут пишем: :startbruting.\nКод\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @echo off :: config.txt if exist \u0026#34;config.txt\u0026#34; ( for /f \u0026#34;tokens=1,* delims==\u0026#34; %%a in (config.txt) do ( set %%a=%%b ) ) :: 7z if not defined z7dir ( echo - Path to 7z dir: set /p z7dir=\u0026#34;#: \u0026#34; ) if not exist \u0026#34;%z7dir%\u0026#34; ( echo. echo ERROR! echo 7z dir - \u0026#34;%z7dir%\u0026#34; echo Not be found... pause exit ) echo Path to 7z: %z7dir% echo OK! echo. :: WinRAR Archive if not defined archive ( echo - Path to archive: set /p archive=\u0026#34;#: \u0026#34; ) if not exist \u0026#34;%archive%\u0026#34; ( echo. echo ERROR! echo Archive - \u0026#34;%archive%\u0026#34; echo Not be found... pause exit ) echo Path to archive: %archive% echo OK! echo. :: Output if not defined output ( echo - Path to output: set /p output=\u0026#34;#: \u0026#34; ) echo Path to output: %output% echo. :: Wordlist if not defined wordlist ( echo - Path to wordlist.txt: set /p wordlist=\u0026#34;#: \u0026#34; ) if not exist \u0026#34;%wordlist%\u0026#34; ( echo. echo ERROR! echo Wordlist - \u0026#34;%wordlist%\u0026#34; echo Not be found... pause exit ) echo Wordlist: %wordlist% echo OK! echo. :: Yes OR Not? :yesornot echo Start bruting? (y/n) set /p yesornot=\u0026#34;#: \u0026#34; if /I \u0026#34;%yesornot%\u0026#34;==\u0026#34;y\u0026#34; ( call :startbruting ) else if /I \u0026#34;%yesornot%\u0026#34;==\u0026#34;n\u0026#34; ( echo OK! pause exit ) else ( echo ERROR! echo. call :yesornot ) :startbruting echo . echo Starting bruting... echo. :: Wordlist for for /f \u0026#34;tokens=*\u0026#34; %%a in (\u0026#39;type \u0026#34;%wordlist%\u0026#34;\u0026#39;) do ( set pwd=%%a call :try ) echo. echo Oh-uh... Password not be found... pause exit :try \u0026#34;%z7dir%\\7z.exe\u0026#34; x -p%pwd% \u0026#34;%archive%\u0026#34; -o\u0026#34;%output%\u0026#34; -y \u0026gt;nul 2\u0026gt;\u0026amp;1 echo Try: %pwd% if /I %errorlevel% EQU 0 ( echo. echo Archive was successfully unpacked! echo Password is: %pwd% pause exit ) Источник\r","permalink":"https://nozsh.su/blog/brutfors-arkhiva-winrar/","summary":"Покажу как перебирать пароли от архива WinRAR, используя 7z и Batch.","title":"Брутфорс архива WinRAR"},{"content":"В этой короткой заметки я расскажу как маскировать ссылки на вашем сайте, и не важно это статика или CMS.\nВсе что нужно, это подключить js скрипт туда где он будет загружаться самым последним.\n1 2 3 4 5 6 7 8 9 10 11 12 llinks_moredetail = document .querySelectorAll(\u0026#34;a[href*=\u0026#39;?nt\u0026#39;]\u0026#34;) .forEach((llinks_moredetail) =\u0026gt; { llinks_moredetail.setAttribute(\u0026#34;target\u0026#34;, \u0026#34;moredetail\u0026#34;); llinks_moredetail.setAttribute(\u0026#34;rel\u0026#34;, \u0026#34;noreferrer nofollow noopener\u0026#34;); let llinks_moredetail_href = llinks_moredetail.href.toString().slice(0, -3); llinks_moredetail.setAttribute( \u0026#34;href\u0026#34;, \u0026#34;https://href.li/?\u0026#34; + llinks_moredetail_href ); }); Атрибуты Разберемся с атрибутами ссылки - rel: noreferrer, nofollow, noopener.\nnoreferrer - делает так, чтобы сайт на который вы ссылаетесь, не знал о вашем сайте.\nnofollow - нужен для того чтобы поисковые роботы, игнорировали эту ссылку.\nnoopener - этот атрибут нужен для безопасности. Предотвращает вмешательство в страницу с которой была открыта ссылка.\nПример использования Я написал этот простой скрипт, чтобы контролировать каждую ссылку, которая должна открываться в новой вкладке.\nПример:\nЯ пишу ссылку так: https://nozsh.su/?nt, а получается это - ссылка.\n1 2 3 4 5 6 7 8 9 10 \u0026lt;a href=\u0026#34;https://nozsh.su/?nt\u0026#34;\u0026gt;ссылка\u0026lt;/a\u0026gt; ==\u0026gt;\u0026gt; \u0026lt;a href=\u0026#34;https://href.li/?https://nozsh.su/\u0026#34; target=\u0026#34;moredetail\u0026#34; rel=\u0026#34;noreferrer nofollow noopener\u0026#34; \u0026gt;ссылка\u0026lt;/a \u0026gt; То есть я пишу ?nt в конце ссылки, если хочу чтобы она открывалась в новой вкладке. Так как я предпочитаю, чтобы в новой вкладке открывались в основном только внешние ссылки, я так же добавил атрибуты.\nВы можете использовать скрипт как есть или немного поменять его:\n1 2 3 4 5 6 7 8 9 10 11 12 llinks_moredetail = document .querySelectorAll(\u0026#34;a\u0026#34;) .forEach((llinks_moredetail) =\u0026gt; { llinks_moredetail.setAttribute(\u0026#34;target\u0026#34;, \u0026#34;moredetail\u0026#34;); llinks_moredetail.setAttribute(\u0026#34;rel\u0026#34;, \u0026#34;noreferrer nofollow noopener\u0026#34;); let llinks_moredetail_href = llinks_moredetail.href; llinks_moredetail.setAttribute( \u0026#34;href\u0026#34;, \u0026#34;https://href.li/?\u0026#34; + llinks_moredetail_href ); }); Данный скрипт, берет все ссылки и добавляет href.li с атрибутами.\nПояснение скрипта 1 document.querySelectorAll(\u0026#34;a[href*=\u0026#39;?nt\u0026#39;]\u0026#34;); Выбирает все ссылки которые содержат ?nt.\n1 llinks_moredetail.setAttribute; Назначает атрибуты.\n1 llinks_moredetail.href; Берет атрибут href (то есть саму ссылку).\n1 toString().slice(0, -3); Обрезает ссылку с конца на 3 символа. Так как предполагается что ?nt будет в конце.\n1 2 3 4 llinks_moredetail.setAttribute( \u0026#34;href\u0026#34;, \u0026#34;https://href.li/?\u0026#34; + llinks_moredetail_href ); Меняет атрибут href, подставляет https://href.li/? перед ссылкой.\nНа месте moredetail может быть _blank или abrakadabra - оно в любом случае откроет ссылку в новой вкладке. Я не использую _blank так как есть проблемы с производительностью и безопасностью. Подробнее.\nТак же вы можете редактировать атрибуты и использовать любого другого провайдера, а не href.li.\nПлюсы использования скрипта, а не редактирования ссылок вручную в том, что фактически ссылки остаются чистыми.\nВы можете быстро поменять атрибуты у всех ссылок, или если href.li сломается - вы сможете быстро все исправить, отредактировав скрипт.\n","permalink":"https://nozsh.su/blog/maskirovka-ssylok-na-vashem-saite-cherez-href-li/","summary":"Заметка о том как маскировать ссылки на вашем сайте.","title":"Маскировка ссылок на вашем сайте через href.li"},{"content":"Вы создали кошель на Trust Wallet, закинули туда крипту, и решили поменять телефон. Разумеется вы сохранили N кол-во слов при создании кошеля, и использовали их для восстановления, но крипты - нет.\nВероятней всего вы используйте \u0026ldquo;какую-то другую\u0026rdquo; валюту. Когда вам кто-то кидает крипту, или когда вы сами себе ее кидаете, она \u0026ldquo;включается\u0026rdquo;. Разумеется при восстановлении кошелька, никто ее не включит.\nTrust Wallet (Android)\rНажимаем на два круга сверху справа. Используем поиск, если не можем найти нужную валюту. \u0026ldquo;Включаем\u0026rdquo; нужную валюту. ","permalink":"https://nozsh.su/blog/trust-wallet-nulevoi-balans/","summary":"Нулевой баланс на Trust Wallet после восстановления, как быть?","title":"Trust Wallet - Нулевой баланс"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 diskpart # Запустить diskpart lis dis # list disk # Список дисков sel dis $ # select disk # Выбираем накопитель ($ = цифра, счет начинается с 0) det dis # detail disk # Информация о диске. Убедиться что это тот самый диск. clean # Очищаем cre par pri # create partition primary # Создаём раздел sel par 1 # select partition # Выбираем раздел (счет начинается с 1) active # Делаем раздел активным. Если выдаст ошибку, пропускаем и идем дальше. format fs=$ quick # Форматируем в файловую систему например: fat32, ntfs, опционально label=«name» - имя накопителя. Quick - быстрое форматирование. assign # Назначаем букву, чтобы накопитель появился в проводнике. exit # Выход из diskpart Подробнее об активных разделах.\n","permalink":"https://nozsh.su/blog/udalenie-razdelov-nakopitelia/","summary":"Как удалить разделы флешки, диска, etc.","title":"Удаление разделов накопителя"},{"content":"Часть этого контента или весь контент подготовлен с помощью ИИ.\nВесь материал, созданный ИИ, прошел проверку.\nТем не менее, настоятельно рекомендуется тщательно анализировать и проверять информацию.\n","permalink":"https://nozsh.su/blog/by-ai/","summary":"Часть этого контента подготовлена с помощью ИИ.","title":"By AI"}]